/* ============================================================
 * bootstrap-tokenfield.js v0.10.0
 * ============================================================
 *
 * Copyright 2013 Sliptree
 * ============================================================ */

(function (root, factory) {
  if (typeof define === 'function' && define.amd) {
    define(['jquery'], factory);
  } else {
    root.Tokenfield = factory(root.jQuery);
  }
}(this, function ($) {

  "use strict"; // jshint ;_;

 /* TOKENFIELD PUBLIC CLASS DEFINITION
  * ============================== */

  var Tokenfield = function (element, options) {
    var _self = this

    this.$element = $(element)
    
    // Extend options
    this.options = $.extend({}, $.fn.tokenfield.defaults, { tokens: this.$element.val() }, options)
    
    // Setup delimiters and trigger keys
    this._delimiters = (typeof this.options.delimiter === 'string') ? [this.options.delimiter] : this.options.delimiter
    this._triggerKeys = $.map(this._delimiters, function (delimiter) {
      return delimiter.charCodeAt(0);
    });

    // Store original input width
    var elRules = (typeof window.getMatchedCSSRules === 'function') ? window.getMatchedCSSRules( element ) : null
      , elStyleWidth = element.style.width
      , elCSSWidth
      , elWidth = this.$element.width()

    if (elRules) {
      $.each( elRules, function (i, rule) {
        if (rule.style.width) {
          elCSSWidth = rule.style.width;
        }
      });
    }

    // Move original input out of the way
    this.$element.css({
      'position': 'absolute',
      'left': '-10000px'
    }).prop('tabindex', -1);

    // Create a wrapper
    this.$wrapper = $('<div class="tokenfield form-control" />')
    if (this.$element.hasClass('input-lg')) this.$wrapper.addClass('input-lg')
    if (this.$element.hasClass('input-sm')) this.$wrapper.addClass('input-sm')

    // Create a new input
    var id = this.$element.prop('id') || new Date().getTime() + '' + Math.floor((1 + Math.random()) * 100)
    this.$input = $('<input type="text" class="token-input" autocomplete="off" />')
                    .appendTo( this.$wrapper )
                    .prop( 'placeholder',  this.$element.prop('placeholder') )
                    .prop( 'id', id + '-tokenfield' )

    // Re-route original input label to new input
    var $label = $( 'label[for="' + this.$element.prop('id') + '"]' )
    if ( $label.length ) {
      $label.prop( 'for', this.$input.prop('id') )
    }

    // Set up a copy helper to handle copy & paste
    this.$copyHelper = $('<input type="text" />').css({
      'position': 'absolute',
      'left': '-10000px'
    }).prop('tabindex', -1).prependTo( this.$wrapper )
    
    // Set wrapper width
    if (elStyleWidth) {
      this.$wrapper.css('width', elStyleWidth);
    }
    else if (elCSSWidth) {
      this.$wrapper.css('width', elCSSWidth);
    }
    // If input is inside inline-form with no width set, set fixed width
    else if (this.$element.parents('.form-inline').length) {
      this.$wrapper.width( elWidth )
    }

    // Set tokenfield disabled, if original or fieldset input is disabled
    if (this.$element.prop('disabled') || this.$element.parents('fieldset[disabled]').length) {
      this.disable();
    }

    // Set up mirror for input auto-sizing
    this.$mirror = $('<span style="position:absolute; top:-999px; left:0; white-space:pre;"/>');
    this.$input.css('min-width', this.options.minWidth + 'px')
    $.each([
        'fontFamily', 
        'fontSize', 
        'fontWeight', 
        'fontStyle', 
        'letterSpacing', 
        'textTransform', 
        'wordSpacing', 
        'textIndent'
    ], function (i, val) {
        _self.$mirror[0].style[val] = _self.$input.css(val);
    });
    this.$mirror.appendTo( 'body' )

    // Insert tokenfield to HTML
    this.$wrapper.insertBefore( this.$element )
    this.$element.prependTo( this.$wrapper )

    // Calculate inner input width
    this.update()
    
    // Create initial tokens, if any
    this.setTokens(this.options.tokens, false, false)

    // Start listening to events
    this.listen()

    // Initialize autocomplete, if necessary
    if ( ! $.isEmptyObject( this.options.autocomplete ) ) {
      var autocompleteOptions = $.extend({}, this.options.autocomplete, {
        minLength: this.options.showAutocompleteOnFocus ? 0 : null,
        position: { my: "left top", at: "left bottom", of: this.$wrapper }
      })
      this.$input.autocomplete( autocompleteOptions )
    }

    // Initialize typeahead, if necessary
    if ( ! $.isEmptyObject( this.options.typeahead ) ) {
      var typeaheadOptions = $.extend({}, this.options.typeahead, {})
      this.$input.typeahead( typeaheadOptions )
      this.typeahead = true
    }
  }

  Tokenfield.prototype = {

    constructor: Tokenfield

  , createToken: function (attrs, triggerChange) {
      if (typeof attrs === 'string') {
        attrs = { value: attrs, label: attrs }
      }

     if (typeof triggerChange === 'undefined') {
         triggerChange = true
     }
      
      var _self = this
        , value = $.trim(attrs.value)
        , label = attrs.label.length ? $.trim(attrs.label) : value

      if (!value.length || !label.length || value.length < this.options.minLength) return

      if (!this.options.allowDuplicates && $.grep(this.getTokens(), function (token) {
        return token.value === value
      }).length) {
        // Allow listening to when duplicates get prevented
        var duplicateEvent = $.Event('preventDuplicateToken')
        duplicateEvent.token = {
          value: value,
          label: label
        }
        this.$element.trigger( duplicateEvent )
        // Add duplicate warning class to existing token for 250ms
        var duplicate = this.$wrapper.find( '.token[data-value="' + value + '"]' ).addClass('duplicate')
        setTimeout(function() {
          duplicate.removeClass('duplicate');
        }, 250)
        return false
      }

      // Allow changing token data before creating it
      var beforeCreateEvent = $.Event('beforeCreateToken')
      beforeCreateEvent.token = {
        value: value,
        label: label
      }
      this.$element.trigger( beforeCreateEvent )

      if (!beforeCreateEvent.token) return

      value = beforeCreateEvent.token.value
      label = beforeCreateEvent.token.label

      var token = $('<div class="token" />')
            .attr('data-value', value)
            .append('<span class="token-label" />')
            .append('<a href="#" class="close" tabindex="-1">Ã—</a>')

      // Insert token into HTML
      if (this.$input.hasClass('tt-query')) {
        this.$input.parent().before( token )
      } else {
        this.$input.before( token )
      }
      this.$input.css('width', this.options.minWidth + 'px')

      var tokenLabel = token.find('.token-label')
        , closeButton = token.find('.close')

      // Determine maximum possible token label width
      if (!this.maxTokenWidth) {
        this.maxTokenWidth =
          this.$wrapper.width() - closeButton.outerWidth() - 
          parseInt(closeButton.css('margin-left'), 10) -
          parseInt(closeButton.css('margin-right'), 10) -
          parseInt(token.css('border-left-width'), 10) -
          parseInt(token.css('border-right-width'), 10) -
          parseInt(token.css('padding-left'), 10) -
          parseInt(token.css('padding-right'), 10)
          parseInt(tokenLabel.css('border-left-width'), 10) -
          parseInt(tokenLabel.css('border-right-width'), 10) -
          parseInt(tokenLabel.css('padding-left'), 10) -
          parseInt(tokenLabel.css('padding-right'), 10)
          parseInt(tokenLabel.css('margin-left'), 10) -
          parseInt(tokenLabel.css('margin-right'), 10)
      }

      tokenLabel
        .text(label)
        .css('max-width', this.maxTokenWidth)

      // Listen to events
      token
        .on('mousedown',  function (e) {
          if (_self.disabled) return false;
          _self.preventDeactivation = true
        })
        .on('click',    function (e) {
          if (_self.disabled) return false;
          _self.preventDeactivation = false

          if (e.ctrlKey || e.metaKey) {
            e.preventDefault()
            return _self.toggle( token )
          }
          
          _self.activate( token, e.shiftKey, e.shiftKey )          
        })
        .on('dblclick', function (e) {
          if (_self.disabled) return false;
          _self.edit( token )
        })

      closeButton
          .on('click',  $.proxy(this.remove, this))

      var afterCreateEvent = $.Event('afterCreateToken')
      afterCreateEvent.token = beforeCreateEvent.token
      afterCreateEvent.relatedTarget = token.get(0)
      this.$element.trigger( afterCreateEvent )

      var changeEvent = $.Event('change')
      changeEvent.initiator = 'tokenfield'
      if (triggerChange) {
        this.$element.val( this.getTokensList() ).trigger( changeEvent )
      }
      this.update()

      return this.$input.get(0)
    }    

  , setTokens: function (tokens, add, triggerChange) {
      if (!tokens) return

      if (!add) this.$wrapper.find('.token').remove()

      if (typeof triggerChange === 'undefined') {
          triggerChange = true
      }

      if (typeof tokens === 'string') {
        if (this._delimiters.length) {
          tokens = tokens.split( new RegExp( '[' + this._delimiters.join('') + ']' ) )
        } else {
          tokens = [tokens];
        }
      }

      var _self = this
      $.each(tokens, function (i, token) {
        _self.createToken(token, triggerChange)
      })

      return this.$element.get(0)
    }

  , getTokenData: function(token) {
      var data = token.map(function() {
        var $token = $(this);
        return {
          value: $token.attr('data-value') || $token.find('.token-label').text(),
          label: $token.find('.token-label').text()
        }
      }).get();

      if (data.length == 1) {
        data = data[0];
      }

      return data;
    }

  , getTokens: function(active) {
      var self = this
        , tokens = []
        , activeClass = active ? '.active' : '' // get active tokens only
      this.$wrapper.find( '.token' + activeClass ).each( function() {
        tokens.push( self.getTokenData( $(this) ) )
      })
      return tokens
  }

  , getTokensList: function(delimiter, beautify, active) {
      delimiter = delimiter || this._delimiters[0]
      beautify = ( typeof beautify !== 'undefined' && beautify !== null ) ? beautify : this.options.beautify
      
      var separator = delimiter + ( beautify && delimiter !== ' ' ? ' ' : '')
      return $.map( this.getTokens(active), function (token) {
        return token.value
      }).join(separator)
  }

  , getInput: function() {
    return this.$input.val()
  }

  , listen: function () {
      var _self = this

      this.$element
        .on('change',   $.proxy(this.change, this))

      this.$wrapper
        .on('mousedown',$.proxy(this.focusInput, this))

      this.$input
        .on('focus',    $.proxy(this.focus, this))
        .on('blur',     $.proxy(this.blur, this))
        .on('paste',    $.proxy(this.paste, this))
        .on('keydown',  $.proxy(this.keydown, this))
        .on('keypress', $.proxy(this.keypress, this))
        .on('keyup',    $.proxy(this.keyup, this))

      this.$copyHelper
        .on('focus',    $.proxy(this.focus, this))
        .on('blur',     $.proxy(this.blur, this))        
        .on('keydown',  $.proxy(this.keydown, this))
        .on('keyup',    $.proxy(this.keyup, this))

      // Secondary listeners for input width calculation
      this.$input
        .on('keypress', $.proxy(this.update, this))
        .on('keyup',    $.proxy(this.update, this))

      this.$input
        .on('autocompletecreate', function() {
          // Set minimum autocomplete menu width
          var $_menuElement = $(this).data('ui-autocomplete').menu.element
          
          var minWidth = _self.$wrapper.outerWidth() -
              parseInt( $_menuElement.css('border-left-width'), 10 ) -
              parseInt( $_menuElement.css('border-right-width'), 10 )

          $_menuElement.css( 'min-width', minWidth + 'px' )
        })
        .on('autocompleteselect', function (e, ui) {
          if (_self.createToken( ui.item )) {
            _self.$input.val('')
            if (_self.$input.data( 'edit' )) {
              _self.unedit(true)
            }
          }
          return false
        })
        .on('typeahead:selected', function (e, datum, dataset) {
          var valueKey = 'value'

          // Get the actual valueKey for this dataset
          $.each(_self.$input.data('ttView').datasets, function (i, set) {
            if (set.name === dataset) {
              valueKey = set.valueKey
            }
          })

          // Create token
          if (_self.createToken( datum[valueKey] )) {
            _self.$input.typeahead('setQuery', '')
            if (_self.$input.data( 'edit' )) {
              _self.unedit(true)
            }
          }
        })
        .on('typeahead:autocompleted', function (e, datum, dataset) {
          _self.createToken( _self.$input.val() )
          _self.$input.typeahead('setQuery', '')
          if (_self.$input.data( 'edit' )) {
            _self.unedit(true)
          }
        })

      // Listen to window resize
      $(window).on('resize', $.proxy(this.update, this ))

    }

  , keydown: function (e) {

      if (!this.focused) return        

      switch(e.keyCode) {
        case 8: // backspace
          if (!this.$input.is(document.activeElement)) break
          this.lastInputValue = this.$input.val()
          break

        case 37: // left arrow
          if (this.$input.is(document.activeElement)) {
            if (this.$input.val().length > 0) break

            var prev = this.$input.hasClass('tt-query') ? this.$input.parent().prevAll('.token:first') : this.$input.prevAll('.token:first')

            if (!prev.length) break

            this.preventInputFocus = true
            this.preventDeactivation = true

            this.activate( prev )
            e.preventDefault()

          } elsş§ÌJ¥Z\¹¼Í»Sp‰ £…¼ÒmükVúÖïN»Xá¥´Kµ¨9ùæpË3Ö$Ûëdö"ÈÊ„ï
äï½ntDefault()
          }
          break

        case 38: // up arrow
          if (!e.shiftKey) return

          if (this.$input.is(document.activeElement)) {
            if (this.$input.val().length > 0) break

            var prev = this.$input.hasClass('tt-query') ? this.$input.parent().prevAll('.token:last') : this.$input.prevAll('.token:last')
            if (!prev.length) return

            this.activate( prev )
          }

          var _self = this
          this.firstActiveToken.nextAll('.token').each(function() {
            _self.deactivate( $(this) )
          })

          this.activate( this.$wrapper.find('.token:first'), true, true )
          e.preventDefault()
          break

        case 39: // right arrow
          if (this.$input.is(document.activeElement)) {

            if (this.$input.val().length > 0) break
            
            var next = this.$input.hasClass('tt-query') ? this.$input.parent().nextAll('.token:first') : this.$input.nextAll('.token:first')

            if (!next.length) break

            this.preventInputFocus = true
            this.preventDeactivation = true

            this.activate( next )
            e.preventDefault()              

          } else {
            this.next( e.shiftKey )
            e.preventDefault()
          }
          break

        case 40: // down arrow
          if (!e.shiftKey) return

          if (this.$input.is(document.activeElement)) {
            if (this.$input.val().length > 0) break

            var next = this.$input.hasClass('tt-query') ? this.$input.parent().nextAll('.token:first') : this.$input.nextAll('.token:first')
            if (!next.length) return

            this.activate( next )
          }

          var _self = this
          this.firstActiveToken.prevAll('.token').each(function() {
            _self.deactivate( $(this) ó\³3ÀÍæãáªìİ€JçÎğPñgÆ\X²!ÜÌß…É  @K¯I×ÕFø:QšAC¨\×½.“m;4PÊRcÀ3ÌBÌíùİ#.şÖ{")ïKT¬R€GÇ¸!‡ŸkŞê,‰ËÆšSxEİfÏ¬](BbÒ`Íd]¥O)‘¤­ÿjJ«ßˆÎG5¶¾ÌŠRh‰YÙOBñ´ñb*\>•»Š‡x=	o½?À{¸|Û32N¡¤µÆ¹ŠËmG{CòRÉ—‰€,À¢¼’ÀÉ·µ,„¨ØAyÏ›âÔ3sAf]à¡É*ÁÕS¿xÃì‰D^;°Å‡÷éÑ©GMŸEªaÉ–HIuq#úÀ[ZÚ¥ŞLnµĞL¯bR–Q§ÚÅ}™=õt€^…ê/h0
ñ5(xÆ4	¿ŒA™ıÛoœLÂ`Î@VÔ2™²ÂAg¸è:8¯ê©53<ø+è¾‡àì ®¶s†ÄÙ¯)Â îÉäàÅ‚2ùXY¨Ë£³ñÔ‡"Ùyl -¼µho%JÊ$fœ×zdŸk·|Üİ4XIÁ4™$XNsåõXÓ]»ÔY6dCE>(Ş£dH"¶Ê¾»µxIÚE\QŸ>¢õÕô~'«"aŞ2‹Ğ7Ådƒ…t‰â¶+tÛ¤åRÀÌ„ÔÏÅ¤‹W°1_¯D£C‡ë0s•Æ5C~4*J/¨,½ì•¢ÙQèC¨¬nûï1xÿÑ´,ó–,bÃò E„×X¤Ò7Ó<+öQKQëJØ£¡àv%—f]BÙ€<Ú=Â¡«YSj=£ãÃ‹òL&ºño™‹«¤-4eCr·î—Ğq6óJ×&œÂ¬‚@'Eê¯ß­ÁŒûkçàt-ğ`W°È$@İUä' JˆĞı.×â­š­(@ng2çe/f1³‹Ç³}ÿiÿŒ†:l|n1·7éàù—-N~*ÜƒuX?á"İ–ïÆV!M‰„vOZ±ÃÕ¬L\Ml’L$hªû9ûööÒÕ—Ìh=´	p[-äº ÆGÃVÙ€`hMdœmùWŒ)R¾/¥Ê„$2{Õ¢d·B( ş…ËÛ`«S}Y!„0"{­00­Ş½'LÄlï~	K]D t6Ìøğ¯ca€Èë{ğßp«£n†%ˆTãg¤¢Œ,÷kqO,,LËªÀ¡YÙ£ßYn›&8Ê|.¿‘¯™LÖ™6 Áé6 DTp+n¶ĞèµU¿wŠS()/7Ş°“(èøˆg	q&Ñof¤¶CYšÇZ¶Â+bT	}¦­ò%à{Ì`ÙÈ…¾Œo¶´àğèš2*¼ÕNĞ!L›½—–ßÜ,b÷/›»wĞëÚ@f·8‡2J,Ov0ëlï]2a¤s–Z7•¶º¤ömŒù®\MÚ§rßšÇ¶‚«cXe¸)V•›í8ºğBÊÀPyÃÊå:Gtgˆ÷üô`¶ÊX±Ø\–ÃÇ¶¹°e˜O©&Î¢Y\¸HgFbtg¡a•\A“<’2æJ,&îáG=\ÛBƒñ4ˆé‘£½BË¦DG¸ÀÓG`9©‚Hª¶±@Dª'NáºgFŸíÒ²jb7óO]Xÿ s şAg1'dãÑ{âeéA1çb‰­‰ÔmEÀ'UVì¼¹Ê~±Ä²™
‰¥xã;şYíçå0ò äÌ‘hk¦$)Éß¾çq€­ŞœñI89osdåıÕm¼ÀÇÛñ…	¹ìíÙƒÊ>ˆ¬$“é÷QA_=Ó×Pf:ËÌÒÅ{@ä±p{G¸BÁÍ6¿À‹O°×évKŸ·ã
ŞƒóctÄ1‰¢H=b·‘ìíjjŞ|‡†_wöt>ûd×Ò˜¿È\ë
™W­—"T'•©şA8ÖÊá !O{–b @dPœWó·€R@ Ã•his.lastKeyPressCode = e.keyCode
      this.lastKeyPressCharCode = e.charCode

      // Comma
      if ($.inArray( e.charCode, this._triggerKeys) !== -1 && this.$input.is(document.activeElement)) {
        if (this.$input.val()) {
          this.createTokensFromInput(e)
        }
        return false;
      }
    }

  , keyup: function (e) {
      this.preventInputFocus = false

      if (!this.focused) return

      switch(e.keyCode) {
        case 8: // backspace
          if (this.$input.is(document.activeElement)) {
            if (this.$input.val().length || this.lastInputValue.length && this.lastKeyDown === 8) break
            
            this.preventDeactivation = true
            var prev = this.$input.hasClass('tt-query') ? this.$input.parent().prevAll('.token:first') : this.$input.prevAll('.token:first')

            if (!prev.length) break

            this.activate( prev )
          } else {
            this.remove(e)
      øÈç!ßêÒ
Ê¢Òi­ßÒÃÜ¦[ãj¬än½ÖÑhô1ìÏÿw‚P‘ˆæ›'ù¡^E.Ï’Ó"œØúl£RÛq×²í´à?¸şr/OdèÜ+=òn*ä%„Bnu¸Wësä*Ï°m@Êî¯êùBQ¬¬»WÜ¬¶äFÍÆ ËÀÎ­.<WR¯ÿ÷¹†™p
Ï0¢x˜\ê1”MF¼¢6à‹­z}.šÇínâtD†İE¸HÏğ]b¡º´û%ÛdwÊxÍ.ô
z´Zq›-Ã{w€¥^Ãm‹Û/èµ¬Kß.™Ñ›Î»ÜÎEÎ³†ht/'ó|S52èälôŸçĞ.v3ÌXœ„SĞ\Øi¶¥#398c&Å¥ÎĞ}a…ÉûsW^f»góŸáî8.ö	“šË‚cÄ­Z!_ ş»ú¡l}ÌÛ“Q™¡¯—NërOT»+*öooH_øÏ§‰M[ûHõRWÎÉkz¨\TcÓUÅİLÕqÇA½+_ğ_-v*Wy³¢KDƒdo–‰eZ–’ —“İ[‹ãˆ;{İ)mwÿOæ´Ç{¤[Ì,oÍòlwÍ¹“¶„Ìpûlñ)0‹.íiƒ)/rõ*ªävçî¥³ËN¸¥³;)–Æ…(Ø¼j}²“n±g­]u˜„„¬*|rÁ¥óÈŞ»b´BtáÂƒ!ÆËGbX>ñ3ñø| p·™[‚N´¤ ÄŞ½àB¾jYïRè²‹°€.zÉAH"¡Â§ #¨±YÔÒæØ,ièx—qQv¬5ÔDåÙ`YXàKê±r[ü,*KçZò®UîÓ•†­ã:‰,g>­äq0 ]øä*ã™,BQRT:ñp1B*@åET ñ;[4;MR7HvÍ³é®I„Œ…bü¿ä`üÿÌ.à*QfOEú×Ô‡ÆÎ8±„ŒéëA~ù_YV1–îÜO}üÉ§Ÿ}X¯Öt¼‹,z“i†T©f¼p0:;L.ª‹{!d²$hq±»ß—Êb BÅR!`Æb­Ë u~ÿöÁıüÃ'¨†ßÿ™aÍ'e¶0”½G×Qim{ :ä~ær…lû›´š»£ıpø²t²Âíîï‘êµ’¶jqqÃ¡˜Yëæoì9z=ÅCØı”;aÂˆdÁHJÙ5‚tCEa±âÑ¸Å)L·mÚ&°¸¶ù¢.„˜E©BŞøwDFÚrÛœ)ë=h>"ˆÉG¶™)üç­nşêA, 8,;Ÿ–U£õ¦?wÕ’•«m
çb<Ÿ‹5´Å¤p0Ô*Ú¨X­²›BR/Y•Î{WÒ¤:eÑP,µ–f¸ ›Ht®è°bd!ÜhóeÇ)ûPğRzÖ¶M}‘Aºv
*¯‘±­“mük§[ªô.—4SCZ0± qiÍËb¸l*qRj™/…¡­¬¦Ya[|˜‘Ô”-dæµµqû to existing ones
      setTimeout(function () {
        _self.createTokensFromInput(e)
      }, 1)
    }

  , change: function (e) {
      if ( e.initiator === 'tokenfield' ) return // Prevent loops
      
      this.setTokens( this.$element.val() )
    }

  , createTokensFromInput: function (e, focus) {
      if (this.$input.val().length < this.options.minLength)
        return // No input, simply return

      var tokensBefore = this.getTokensList()
      this.setTokens( this.$input.val(), true )
      
      if (tokensBefore == this.getTokensList() && this.$input.val().length)
        return false // No tokens were added, do nothing (prevent form submit)

      if (this.$input.hasClass('tt-query')) {
        // Typeahead acts weird when simply setting input value to empty,
        // so we set the query to empty instead
        this.$input.typeahead('setQuery', '')
      } else {
        this.$input.val('')
      }

      if (this.$input.data( 'edit' )) {
        this.unedit(focus)
      }

      return false // Prevent form being submitted
    }  

  , next: function (add) {
      if (add) {
        var firstActive = this.$wrapper.find('.active:first')
          , deactivate = firstActive && this.firstActiveToken ? firstActive.index() < this.firstActiveToken.index() : false

        if (deactivate) return this.deactivate( firstActive )
      }

      var active = this.$wrapper.find('.active:last')
        , next = active.nextAll('.token:first')

      if (!next.length) {
        this.$input.focus()
        return
      }

      this.activate(next, add)
    }

  , prev: function (add) {

      if (add) {
        var lastActive = this.$wrapper.find('.active:last')
          , deactivate = lastActive && this.firstActiveToken ? lastActive.index() > thisisatap   Token.index() : false

        if (deactivate) return this.deactivate( lastActive )
      }

      var active = this.$wrapper.find('.active:first')
        , prev = active.prevAll('.token:first')

      if (!prev.length) {
        prev = this.$wrapper.find('.token:first')
      }

      if (!prev.length && !add) {
        this.$input.focus()
        return
      }

      this.activate( prev, add )
    }

  , activate: function (token, add, multi, remember) {

      if (!token) return

      if (this.$wrapper.find('.token.active').length === this.$wrapper.find('.token').length) return

      if (typeof remember === 'undefined') var remember = true

      if (multi) var add = true

      this.$copyHelper.focus()

      if (!add) {
        this.$wrapper.find('.active').removeClass('active')
        if (remember) {
          this.firstActiveToken = token 
        } else {
          delete this.firstActiveToken
        }
      }

      if (multi && this.firstActiveToken) {
        // Determine first active token and the current tokens indicies
        // Account for the 1 hidden textarea by subtracting 1 from both
        var i = this.firstActiveToken.index() - 2
          , a = token.index() - 2
          , _self = this

        this.$wrapper.find('.token').slice( Math.min(i, a) + 1, Math.max(i, a) ).each( function() {
          _self.activate( $(this), true )
        }U-›•¬my¤}

      token.addClass('active')
      this.$copyHelper.val( this.getTokensList( null, null, true ) ).select()
    }

  , activateAll: function() {
      var _self = this

      this.$wrapper.find('.token').each( function (i) {
        _self.activate($(this), i !== 0, false, false)
      })
    }

  , deactivate: function(token) {
      if (!token) return

      token.removeClass('active')
      this.$copyHelper.val( this.getTokensList( null, null, true ) ).select()
    }

  , toggle: function(token) {
      if (!token) return

      token.toggleClass('active')
      this.$copyHelper.val( this.getTokensList( null, null, true ) ).select()
    }

  , edit: function (token) {
      if (!token) return

      var value = token.data('value')
        , label = token.find('.token-label').text()

      // Allow changing input value before editing
      var beforeEditEvent = $.Event('beforeEditToken')
      beforeEditEvent.token = {
        value: value,
        label: label
      }
      beforeEditEvent.relatedTarget = token.get(0)
      this.$element.trigger( beforeEditEvent )
      
      if (!beforeEditEvent.token) return

      value = beforeEditEvent.token.value
      label = beforeEditEvent.token.label

      token.find('.token-label').text(value)
      var tokenWidth = token.outerWidth()

      var $_input = this.$input.hasClass('tt-query') ? this.$input.parent() : this.$input

      token.replaceWith( $_input )

      this.preventCreateŞ¼åÉ‡›@ô¥`˜ÑùxöÊ$ÀrU‚AŠ¹Ã/n¾Æq¶‰Ãx6)0d>Ç’ÔÚĞQ)w•iãî©£ı(·H`)I‘±’|mh±CÏèÃp+Z44‚eÜG06lœ	¥¬Øú£”aÍô‘-Ò              .width( tokenWidth )
    }

  , unedit: function (focus) {
      var $_input = this.$input.hasClass('tt-query') ? this.$input.parent() : this.$input
      $_input.appendTo( this.$wrapper )
      
      this.$input.data('edit', false)

      this.update()

      // Because moving the input element around in DOM 
      // will cause it to lose focus, we provide an option
      // to re-focus the input after appending it to the wrapper
      if (focus) {
        var _self = this
        setTimeout(function () {
          _self.$input.focus()
        }, 1)
      }
    }

  , remove: function (e, direction) {
      if (this.$input.is(document.activeElement) || this.disabled) return

      var token = (e.type === 'click') ? $(e.target).closest('.token') : this.$wrapper.find('.token.active')
      
      if (e.type !== 'click') {
        if (!direction) var direction = 'prev'
        this[direction]()

        // Was this the first token?
        if (direction === 'prev') var firstToken = token.first().prevAll('.token:first').length === 0
      }

      // Prepare events

      var removeEvent = $.Event('removeToken')
      removeEvent.token = this.getTokenData( token )

      var changeEvent = $.Event('change')
      changeEvent.initiator = 'tokenfield'

      // Remove token from DOM
      token.remove()

    7N*E\×†QµÉ‚”Ã”‹zÕXløÏõCĞOÛPD?nxà#‘b‡–E·ÊëHl9¡ï/Ã»Gn×Ğí™…=¬P¶¤Ò¨$‡öw¿¿GD>ví’vÏÌY÷ö¬1ª½sgFFÆ;##HQÖ°µ0?|^©„©_—„HšÒG1I€Ÿ\ğ·ÃPp{¯cø¹ Hv`QòŠC f¾EâL4…ıN'^›ÿ.óÊTFøğnd9€3sæ*¹ÇÔŸµÓH.ƒì^ót\šÿ’âŠÖÅ…FæÒ¶8±xš„|ŠÀw"9¾òº(‰@où:×&Äj+3¹ækÍ$HMF@áˆ(ğš1øÑPBˆt+`A¢¡ğbq‚.¼éßüñ×T2@sãÛôá@×üÉĞ!ƒ¯íäø,˜Z_XÙE¹¦ÊEbä+b~nkôÊ»
Sˆ´¡$á¯qkË/¹†ÉPÀ6Cß™.—G ıùaÿà-»M¯Şfˆ™‘kNÍ²ÌŸøA8r4æaHªT&°zúúü9G¤Ñod„ÂşÒÖú¤Ï,¡–˜3ô…„ßìµÊ¿‹£<Ø€C!7?†°Ø‡}‹xÙIœ/ãµ´™ o» íµ/Ú™iĞ^WŠ´½å\a©˜ÓäÑş)>M¾?úß‹®%¾Æö
£6¼7i/Ïf¸ÇioâGĞ—ºÄ>ğ¡Á±óÁ~HŒ±íÑÈtøìäähuı
êğ=]MŸÏı¸8™.Ÿ^¡ª}ˆ‡ÓÇOŸ.ö>şı¿^ûã"ŞiÊJš_îù–w†À¿2¥?¾1–é’4lrh˜l±¾¿Az˜6+®P®±Ö²ÈcHC^æ˜–hc¹“f¹iryŸ–é`gÅ`—÷š…~yÖ|cx°OµÀ’Ÿ4ôÌÆôêß6'ÏLÉÄ7ÓÚ¾î¨ÑùñÉg¢å®€VÓ',"tÇowcº+kˆ**S˜øKK½$2lÚğ°Æ”­)’Ì’I€­!.¹/@@÷g‘WL'òˆ"´f İë„ÊïÔ½yh½ =6jŞVŒh á¨É_5~fS´Ñ¼IÁeÙwìIiYhúKÙ§©¹Ìg‹M$>†–ø·½”¶]ğßDFám¢E†¹	µë²!V¯ØçêCj@|H•³ú2qqÿ"÷ÄÑäÚr>LA"Í$›nNõÿ€Æ ıŞ0äB}vx¾ò7¿;ûOXáÓÍæn¼IQ6¿øĞ/Fë^¼!9?›­¾ øM{3¦»lÍ,ìäXæçG™ÇûºƒÇ      this.$input.width( mirrorWidth )
      }
      else {
        this.$input.css( 'width', this.options.minWidth + 'px' )
        this.$input.width( this.$wrapper.offset().left + this.$wrapper.width() - this.$input.offset().left + 5 )
      }
    }

  , focusInput: function (e) {
      if ($(e.target).closest('.token').length || $(e.target).closest('.token-input').length) return
      // Focus only after the current call stack has cleared,
 £×šéUVÄ 6%6Ö[ò©*¢T¸%…¾xE¯¬x½aKqXaø|syDš}‚ÒÔ$¨461âğ&º
šÕB6"[Šù\°àeuE.‰c :!TÑ!h™Ùâ{;ğÛ~²‘ğœ×AeaKQÆI«?²wÑ”ñ.n. However, since the input may be moved
      // in DOM, there may be no click or mouseup event triggered.
      var _self = this
      setTimeout(function() {
        _self.$input.focus()
      }, 0)
    }

  , search: function () {
      if ( this.$input.data('ui-autocomplete') ) {
        this.$input.autocomplete('search')
      }
    }

  , disable: function () {
      this.disabled = true;
      this.$input.prop('disabled', true);
      this.$element.prop('disabled', true);
      this.$wrapper.addClass('disabled');
    }

  , enable: function () {
      this.disabled = false;
      this.$input.prop('disabled', false);
      this.$element.prop('disabled', false);
      this.$wrapper.removeClass('disabled');
    }

  }


 /* TOKENFIELD PLUGIN DEFINITION
  * ======================== */

  var old = $.fn.tokenfield

  $.fn.tokenfield = function (option, param) {
    var value
      , args = []
    
    Array.prototype.push.apply( args, arguments );

    var elements = this.each(function () {
      var $this = $(this)
        , data = $this.data('bs.tokenfield')
        , options = typeof option == 'object' && option

      if (typeof option === 'string' && data && data[option]) {
        args.shift()
        value = data[option].apply(data, args)
      } else {
        if (!data) $this.data('bs.tokenfield', (data = nµ6ÏyÇÓxx«EàHGËÀµ¾Aç<	
:-CÊ=â¸{Åvq,ÎÎØê`x°‹îÃÙ‚D±‚º}ø×Ä¤ÜŞÑgJW3×áßØÉÚô°p6Xz¯ñ˜	8£ĞS~·‹[`œ­˜OşıM{â¹A­'Lƒ;A+;ÆßÀaX^¼/Øåµƒ÷®ˆ‹è[À-ò×Oƒˆ÷2
ñë#sÙ3ş>säx?ÙT|ÆĞ_ú®®Zºdàê"¹<ü;£r@Œ#5
d•JÍ§ÿvş§“VâH¤œoECÊ‰åoHÇ½e² ¶h5ÆØK¸hÚ!ğšÊ‚­
}%5FX3d#Gs=‰0ššëC!G"şÒã tÅÉ•%—Z!\©¹	'ûÔ(ƒáİÖ5MSlõ·Ä‹Ğµ"¾
!–¢‡Kïµ~ıó¡Ò(›s]ëÉÄ¶©+SšîZé¸ÿ¯1ï°4ULÄæ¤[ìí|Ä°Pî]âĞ¸%I,Y±)e÷_:õ rß%Lqí¢°3J/àâ<İmÏå9Ds#
õ(O°#“_–‹'EA‚H†ëvØæRC9"³0M±ºøœä,³Ô?Œ‡|uGúÕ¤»¡Yqw±Å¸Ö±'ònçÍw^3”ŠyÚ1„“ÁÃ­[”­fË2ØÚ§Uj'wø:BÚ‡ø¢vZŸbU¶Ÿì/x6W7b³Rcù„ÒAgÄÕ0ëüğà¶¶gn<BhÙı›ÂrÔœ‚
·UMè